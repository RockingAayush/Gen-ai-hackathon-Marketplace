import os
import io
import base64
from typing import List, Optional
from math import log

from dotenv import load_dotenv
from fastapi import FastAPI, UploadFile, Form, HTTPException
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from PIL import Image
import numpy as np
from sklearn.cluster import DBSCAN

from google import genai
from google.genai import types

# -------------------- Load environment --------------------
load_dotenv()
API_KEY = os.getenv("GEMINI_API_KEY")

# -------------------- Initialize --------------------
app = FastAPI()
client = genai.Client(api_key=API_KEY)

# -------------------- Unified Artisan Model --------------------
class Artisan(BaseModel):
    id: int
    name: str
    latitude: float
    longitude: float
    art_style: Optional[str] = None
    avg_rating: Optional[float] = None  # 0-5 scale
    num_reviews: Optional[int] = None   # total reviews

# -------------------- Translation --------------------
class TranslationRequest(BaseModel):
    text: str
    lang: str

@app.post("/translate")
async def translate(req: TranslationRequest):
    prompt = f"Translate the following text to {req.lang}. Only return the translated text, nothing else:\n\n{req.text}"
    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=prompt
    )
    return {"translation": response.text}

# -------------------- Image Caption --------------------
@app.post("/caption")
async def caption(image: UploadFile, lang: str = Form(...)):
    img_bytes = await image.read()
    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=[
            f"Describe this image in {lang}.",
            {
                "inline_data": {
                    "mime_type": image.content_type,
                    "data": img_bytes
                }
            }
        ]
    )
    return {"caption": response.text}

# -------------------- Rotate Image --------------------
@app.post("/rotate_image")
async def rotate(
    image: UploadFile,
    angle: int = Form(...),
    description: str = Form("Generate a marketplace-ready rotated view.")
):
    img_bytes = await image.read()
    prompt = (
        f"{description} Rotate the product image by {angle} degrees considering a vertical axis, "
        "showing the new viewpoint as if displayed in an online marketplace."
    )

    try:
        response = client.models.generate_content(
            model="gemini-2.5-flash-image-preview",
            contents=[
                prompt,
                types.Part(
                    inline_data=types.Blob(
                        mime_type=image.content_type,
                        data=img_bytes
                    )
                )
            ]
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Gemini API error: {e}")

    candidate = response.candidates[0]
    img_part = None
    for part in candidate.content.parts:
        if part.inline_data is not None:
            img_part = part
            break

    if img_part is None or not img_part.inline_data.data:
        raise HTTPException(status_code=500, detail="No image generated by Gemini")

    img_b64 = img_part.inline_data.data
    img_decoded = base64.b64decode(img_b64)
    return StreamingResponse(io.BytesIO(img_decoded), media_type="image/png")

# -------------------- Cluster Artisans --------------------
class ClusterRequest(BaseModel):
    artisans: List[Artisan]
    eps_km: float = 5  # max distance in km to consider same cluster

class ClusteredArtisan(BaseModel):
    id: int
    name: str
    latitude: float
    longitude: float
    cluster: int
    art_style: Optional[str] = None
    avg_rating: Optional[float] = None
    num_reviews: Optional[int] = None

@app.post("/cluster_artisans", response_model=List[ClusteredArtisan])
async def cluster_artisans(req: ClusterRequest):
    if not req.artisans:
        return []

    coords = np.array([[a.latitude, a.longitude] for a in req.artisans])
    coords_rad = np.radians(coords)
    earth_radius = 6371.0

    clustering = DBSCAN(
        eps=req.eps_km / earth_radius,
        min_samples=1,
        metric='haversine'
    ).fit(coords_rad)

    labels = clustering.labels_
    clustered = []
    for artisan, label in zip(req.artisans, labels):
        clustered.append(ClusteredArtisan(
            id=artisan.id,
            name=artisan.name,
            latitude=artisan.latitude,
            longitude=artisan.longitude,
            cluster=int(label),
            art_style=artisan.art_style,
            avg_rating=artisan.avg_rating,
            num_reviews=artisan.num_reviews
        ))
    return clustered

# -------------------- Highlight Underrated Artists --------------------
class UnderratedRequest(BaseModel):
    artisans: List[Artisan]
    top_n: int = 3  # number of artists to return

@app.post("/highlight_underrated")
async def highlight_underrated(req: UnderratedRequest):
    MAX_SCORE = 1e9
    if not req.artisans:
        return []

    artist_scores = []
    for artist in req.artisans:
        if artist.avg_rating is None or artist.num_reviews is None:
            continue
        if artist.avg_rating == 0:
            score = MAX_SCORE
        else:
            score = log(artist.num_reviews + 1) / artist.avg_rating
        artist_scores.append((artist, score))

    artist_scores.sort(key=lambda x: x[1], reverse=True)

    top_underrated = []
    for artist, score in artist_scores[:req.top_n]:
        top_underrated.append({
            "id": artist.id,
            "name": artist.name,
            "latitude": artist.latitude,
            "longitude": artist.longitude,
            "art_style": artist.art_style,
            "avg_rating": artist.avg_rating,
            "num_reviews": artist.num_reviews,
            "underrated_score": round(score, 2)
        })

    return top_underrated

